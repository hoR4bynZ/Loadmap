# 第二章：程序结构和执行

## 练习题2.1：
> 完成下列数字转换  
> </br>
> A. 将0x39A7F8转换为二进制  
> B. 将二进制1100100101111011转换为十六进制  
> C. 将0xD5E4C转换为二进制  
> D. 将二进制1001101110011110110101转换为十六进制  
```c
    // A. 0011_1001_1010_0111_1111_1000
    // B. 0xc97b
    // C. 1101_0101_1110_0100_1100
    // D. 0x26e7b5
```

## 练习题2.2：
>填写下表中的空白项，给出2的不同次幂的二进制和十六进制表示  
> n|2<sup>n</sup>(十进制)|2<sup>n</sup>(十六进制)
> -|--------------------|-----------------------
> 9|         512        |         0x200
> 19|                   |
> | |       16384        |
> | |                    |         0x1000
> 17|                    |
> | |        32          |
> | |                    |          0x80

n|2<sup>n</sup>(十进制)|2<sup>n</sup>(十六进制)
-|--------------------|-----------------------
***9***|***512***|***0x200***
***19***|524288|0x80000
14|***16384***|0x4000
16|65536|***0x1000***
***17***|131072|0x20000
5|***32***|0x20
7|128|***0x80***

## 练习题2.3：
> 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制值  
> 十进制|二进制|十六进制
> -----|------|-------
> 0|0000 0000|0x00
> 167|
> 62|
> 188|
> ||0011 0111|
> ||1000 1000|
> ||1111 0011|
> |||0x52
> |||0xAC
> |||0xE7

十进制|二进制|十六进制
-----|------|-------
***0***|***0000 0000***|***0x00***
***167***|1010 0111|0xa7
***62***|0011 1110|0x3e
***188***|1100 1011|0xcb
55|***0011 0111***|0x37
136|***1000 1000***|0x88
243|***1111 0011***|0xf3
82|0101 0010|***0x52***
172|1010 1100|***0xac***
231|1110 0111|***0xe7***

## 练习题2.4：
> 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六机制表示。提示：将执行十进制加法和减法所使用的方法改成以16为基数。  
> </br>
> A. 0x503c + 0x8 =  
> B. 0x503c - 0x40 =   
> C. 0x503c + 67 =  
> D. 0x50ea - 0x503c =
```c
    // A. 0x5044; B. 0x4ffc; C. 0x50a0; D. 0xae
```

## 练习题2.5：
> 思考下面对 show_bytes 的三次调用：  
> int val = 0x87654321;  
> byte_pointer valp = (byte_pointer)&val;  
> show_bytes(valp, 1); /\* A. \*/  
> show_bytes(valp, 2); /\* B. \*/  
> show_bytes(valp, 3); /\* C. \*/  
> 指出在小端法机器和大端法机器上，每次调用的输出值  
> </br>
> A. 小端法：&#8195;&#8195;&#8195;&#8195;大端法：  
> B. 小端法：&#8195;&#8195;&#8195;&#8195;大端法：  
> C. 小端法：&#8195;&#8195;&#8195;&#8195;大端法：  
```c
    // A. 小端法：21；大端法：87
    // A. 小端法：21 43；大端法：87 65
    // A. 小端法：21 43 65；大端法：87 65 43
```

## 练习题2.6：
> 使用 show_int 和 show_float，我们确定整数 3510593 的十六进制表示为 0x00359141，而浮点数 3510593.0 的十六进制表示为 0x4a56_4504  
> </br>
> A. 写出这两个十六进制值的二进制表示  
> B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？  
> C. 串中的什么部分不相匹配？
```c
    // A. 0000_0000_0011_0101_1001_0001_0100_0001; 0100_1010_0101_0110_0100_0101_0000_0100
    // B. 21位匹配
    // C. 整数的开头部分和浮点数的开头部分不相匹配
```

## 练习题2.7：
> 下面对 show_bytes 的调用将输出什么结果？  
> const char *s = "abcdef";  
> show_bytes((byte_pointer)s, strlen(s));  
> 注意字母 'a' ~ 'z' 的 ASCII 码为 0x61 ~ 0x7a
```c
    // 会输出 61 62 63 64 65 66 00
```

## 练习题2.8：
> 填写下表，给出位向量得布尔运算得求值结果。  
> 运算|结果
> ---|---
> a|[0110 1001]
> b|[0101 0101]
> ~a|
> ~b|
> a & b|
> a \| b|
> a ^ b|

运算|结果
---|---
a|[0110 1001]
b|[0101 0101]
~a|[1001 0110]
~b|[1010 1010]
a & b|[0100 0001]
a \| b|[0111 1101]
a ^ b|[0011 1100]

## 练习题2.9：
> 通过混合三种不同颜色得光（红色、绿色和蓝色），计算机可以在视频屏幕或液晶显示器上产生彩色得画面。设想一种简单的方法，使用三种不同颜色的光，每种光都能打开或关闭，投影到玻璃屏幕上，如图所示：  
> </br>
> 那么基于光源 R（红）、G（绿）、B（蓝）的关闭（0）或打开（1），我们就能够创建 8 种不同的颜色：  
> R&#8195;G&#8195;B|颜色
> -----------------|----
> 0&#8195;0&#8195;0|黑色
> 0&#8195;0&#8195;1|蓝色
> 0&#8195;1&#8195;0|绿色
> 0&#8195;1&#8195;1|蓝绿色
> 1&#8195;0&#8195;0|红色
> 1&#8195;0&#8195;1|红紫色
> 1&#8195;1&#8195;0|黄色
> 1&#8195;1&#8195;1|白色  
> 这些颜色中的每一种都能用一个长度为 3 的位向量来表示，我们可以对它们进行布尔运算。  
> </br>
> A. 一种颜色的补是通过关掉打开的光源，且打开关闭的光源而形成的。那么上面列出的 8 种颜色每一种的补是什么？  
> B. 描述下列颜色应用布尔运算的结果：  
> &#8195;蓝色 | 绿色 =  
> &#8195;黄色 & 蓝绿色 =  
> &#8195;红色 ^ 红紫色 = 
```c
    // A. 黑色和白色互为补；蓝色和黄色互为补；绿色和红紫色互为补；蓝绿色和红色互为补
    // B. 蓝绿色；绿色；蓝色
```

## 练习题：2.10：
> 对于任一位向量 a，有 a ^ a = 0。应用这一属性，考虑下面的程序：
>```c
> 1 void inplace_swap(int *x, int *y) {  
> 2     *y = *x ^ *y; /* Step 1 */  
> 3     *x = *x ^ *y; /* Step 2 */  
> 4     *y = *x ^ *y; /* Step 3 */  
> 5 }  
>```
> 正如程序名字所暗示的那样，我们认为这个过程的效果是交换指针变量 x 和 y 所指向的存储位置处存放的值。注意，与通常的交换方式并没有性能上的优势，它仅仅是一个智力游戏。  
> 以指针 x 和 y 指向的位置存储的值分别是 a 和 b 作为开始，填写下表，给出程序的每一步之后，存储在这两个位置中的值。利用 ^ 的属性证明达到了所希望的效果。回想一下，每个元素就是它自身的加法逆元（a ^ a = 0）。  
> 步骤|*x|*y
> -|-|-
> 初始|a|b
> 第一步|
> 第二步|
> 第三步|

***步骤***|***\*x***|***\*y***
-|-|-
***初始***|***a***|***b***
***第一步***|a|a ^ b
***第二步***|a ^ a ^ b|a ^ b
***第三步***|a ^ a ^ b|a ^ a ^ b ^ a ^ b

## 练习题2.11：
> 在练习题2.10中的 inplace_swap 函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端一次对调。你写出下面这个函数：
>```c
> 1 void reverse_array(int a[], int cnt) {  
> 2     int first, last;  
> 3     for (first = 0, last = cnt - 1;  
> 4          first <= last;  
> 5          first++, last--)
> 6         inplace_swap(&a[first], &a[last]);
> 7 }
>```
> 当你对一个包含元素 1、2、3 和 4 的数组使用这个函数时，正如预期的那样，现在数组的元素编程了 4、3、2 和 1。不过，当你对一个包含元素 1、2、3、4 和 5 的数组使用这个函数时，你会很惊奇地看到得到数字得元素为 5、4、0、2 和 1。实际上，你会发现这段代码对所有偶数长度的数组都能正确地工作，但是当数组的长度为奇数时，它就会把中间的元素设置成0。  
> </br>
> A. 对于一个长度为奇数的数组，长度 cnt = 2k + 1，函数 reverse_array 最后一次循环中，变量 first 和 last 的值分别是什么？  
> B. 为什么这时调用函数 xor_swap 会将数组元素设置为 0？  
> C. 对 reverse_array 的代码做哪些简单改动就能消除这个问题？
```c
    // A. 数组最中间的元素，即 a[k]
    // B. 因为是对同一个数进行异或运算
    // C. for() 的条件（Condition）由“first <= last;”改为“first < last;”
```

## 练习题2.12：
> 对于下面的值，写出变量 x 的 C 语言表达式。你的代码应该对任何字长 w ≥ 8 都能工作。我们给出了当 x = 0x87654321 以及 w = 32 时表达式求值的结果，仅供参考。  
> </br>
> A. x的最低有效字节，其他位均置为 0. [0x0000 0021]  
> B. 除了 x 的最低有效字节外，其他的位都取补，最低有效字节保持不变。 [0x789ABC21]  
> C. x的最低有效字节设置成全 1，其他字节都保持不变。 [0x876543FF]
```c
/* A. */
x &= 0xff;
/* B. */
int y = x; x = ~x; x &= 0xffffff00; y &= 0xff; x |= y;
/* C. */
x |= 0xff;
```

## 练习题2.13：
> 从 20 世纪 70 年代末到 80 年代末，Digital Equipment 的 VAX 计算机是一种非常流行的机型。它没有布尔运算 AND 和 OR 指令，只有 bis（位设置）和 bic（位清除）这两种指令。两种指令的输入都是一个数据字 x 和一个掩码字 m。它们生成一个结果 z，z是由根据掩码 m 的位来修改 x 的位得到的。使用 bis 指令，这种修改就是在 m 为 1 的每个位置上，将 z 对应的位设置为 1。使用 bic 指令，这种修改就是在 m 为 1 的每个位置，将 z 对应的位设置为 0。  
> &#8195;&#8195;为了清除因为这些运算与 C 语言位级运算的关系，假设我们有两个函数 bis 和 bic 来实现位设置和位消除操作。只想用这两个函数，而不是用任何其他 C 语言运算，来实现按位 | 和 ^ 运算。填写下列代码中缺失的代码。提示：写出 bis 和 bic 运算的 C 语言表达式。
> ```c
> /* Declarations of functions implementing operations bis and bic */
> int bis(int x, int m);
> int bic(int x, int m);
> 
> /* Compute x|y using only calls to functions bis and bic */
> int bool_or(int x, int y) {
>     int reselt = ______;
>     return result;
> }
> /* Compute x^y using only calls to functions bis and bic */
> int bool_xor(int x, int y){
>     int result = ______;
>     return result;
> }
> ```

> 这题 bis() 根据掩码中 1 的位置，置位位串相应位置，即“只要有 1 就置 1 —— 或运算”  
> 而 bic() 根据掩码中 1 的位置， 清位位串相应位置，即“只要有 1 就清 0 —— 先将 1 取反，然后与运算”
```c
/* Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
    int reselt = bis(x, y);
    return result;
}
/* Compute x^y using only calls to functions bis and bic */
int bool_xor(int x, int y){
    int result = bis(bic(x, y), bis(y, x));
    return result;
}
```

## 练习题2.14
> 假设 x 和 y 的字节值分别为 0x66 和 0x39。填写下表，指明各个 C 表达式的字节值。
> 表达式|值|
> -|-
> x & y|
> x \| y|
> ~x \| ~y|
> x & !y|
> x && y|
> x \|\| y|
> !x \|\| !y|
> x && ~y|
***表达式***|***值***|
-|-
***x & y***|32
***x \| y***|127
***~x \| ~y***|223
***x & !y***|0
***x && y***|1
***x \|\| y***|1
***!x \|\| !y***|0
***x && ~y***|1

## 练习题2.15
> 只使用位级和逻辑运算，编写一个C表达式，它等价于 x == y。换句话说，当 x 和 y 相等时它将返回 1，否则就返回 0。
```shell
root@localhost:/mnt/CSAPP/Ch02$ gcc ex2_15.c -o ex2_15
root@localhost:/mnt/CSAPP/Ch02$ ./ex2_15
Input two numbers to test: 63 63
1
root@localhost:/mnt/CSAPP/Ch02$ ./ex2_15
Input two numbers to test: 63 21
0
```

## 练习题2.16
> 填写下表，说明不同移位运算对单字节数的影响。思考移位运算的最好方式是使用二进制表示。将最初的值转换为二进制执行移位运算，然后再转换回十六进制。每个答案都应该是 8 个二进制数字或者 2 个十六进制数字  
> x|| x << 3|| x >> 2（逻辑的）||x >> 2（算术的）||
> -|-|-|-|-|-|-|-
> 十六进制|二进制|二进制|十六进制|二进制|十六进制|二进制|十六进制
> 0xC3|
> 0x75|
> 0x87|
> 0x66|
***x***|| ***x << 3***|| ***x >> 2（逻辑的）***||***x >> 2（算术的）***||
-|-|-|-|-|-|-|-
***十六进制***|***二进制***|***二进制***|***十六进制***|***二进制***|***十六进制***|***二进制***|***十六进制***
***0xC3***|1100 0011|0001 1000|0x18|0011 0000|0x30|1111 0000|0xf0
***0x75***|0111 0101|1010 1000|0xa8|0001 1101|0x1d|0001 1101|0x1d
***0x87***|1000 0111|0011 1000|0x38|0010 0001|0x21|1110 0001|0xe1
***0x66***|0110 0110|0011 1000|0x38|0001 1001|0x19|0001 1001|0x19

## 练习题2.17
> 假设 w = 4，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出灯饰（2-1）和等式（2-3）所示的求和公式中的 2 的非零次幂，填写下表：
> →x||B2U<sub>4</sub>(→x)|B2T<sub>4</sub>(→x)
> -|-|-|-
> 十六进制|二进制|
> 0xE|[1110]|2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>=14|-2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>=-2
> 0x0|
> 0x5|
> 0x8|
> 0xD|
> 0xF|
***→x***||***B2U<sub>4</sub>(→x)***|***B2T<sub>4</sub>(→x)***
-|-|-|-
***十六进制***|***二进制***|
***0xE***|***[1110]***|***2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>=14***|***-2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>=-2***
***0x0***|[0000]|0|0
***0x5***|[0101]|2<sup>2</sup>+2<sup>0</sup>=5|2<sup>2</sup>+2<sup>0</sup>=5
***0x8***|[1000]|2<sup>3</sup>=8|-2<sup>3</sup>=-8
***0xD***|[1101]|2<sup>3</sup>+2<sup>2</sup>+2<sup>0</sup>=13|-2<sup>3</sup>+2<sup>2</sup>+2<sup>0</sup>=-3
***0xF***|[1111]|2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>+2<sup>0</sup>=15|-2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>+2<sup>0</sup>=-1

## 练习题2.18
> 在第 3 章，我们将看到由反汇编器生成的列表，**反汇编器**是一种将可执行程序文件转换回可读性更好的 ASCII 码形式的程序。这些文件包含许多十六进制数字，都是用典型的补码形式来表示这些值。能够认识这些数字并理解它们的意义（例如，它们是正数还是负数），是一项重要的技巧。  
> &#8195;&#8195;在下面的列表中，对于标号为 A ~ J（标记在右边）的那些行，将指令名（sub、mov 和 add）右边显示的（用 32 位补码形式表示的）十六进制值转换为等价的十进制值。  
> ```asm
> 8048337: 81 ec b8 01 00 00    sub $0x1b8, %esp            A.
> 804833d: 8b 55 08             mov 0x8(%ebp), %edx
> 8048340: 83 c2 14             add $0x14, %edx             B.
> 8048343: 8b 85 58 fe ff ff    mov 0xfffffe58(%ebp), %eax  C.
> 8048349: 03 02                add (%edx), %eax
> 804834b: 89 85 74 fe ff ff    mov %eax, 0xffffe74(%ebp)   D.
> 8048351: 8b 55 08             mov 0x8(%ebp), %edx
> 8048354: 83 c2 44             add $0x44, %edx             E.
> 8048357: 8b 85 c8 fe ff ff    mov 0xfffffec8(%ebp), %eax  F.
> 804835d: 89 02                mov %eax, (%edx)
> 804835f: 8b 45 10             mov 0x10(%ebp), %eax        G.
> 8048362: 03 45 0c             add 0xc(%ebp), %eax         H.
> 8048365: 89 85 ec fe ff ff    mov %eax, 0xfffffeec(%ebp)  I.
> 804836b: 8b 45 08             mov 0x8(%ebp), %eax
> 804836e: 83 c0 20             add $0x20, %eax             J.
> 8048371: 8b 00                mov (%eax), %eax
> ```
```c
    // A. 440;              B. 20;      C. 4,294,966,872
    // D. 4,294,966,872;    E. 68;      F. 4,294,966,984
    // G. 16;               H. 12;      I. 4,294,967,020
    // J. 32
```

## 练习题2.19
> 利用你解答练习题 2.17 时填写的表格，填写下列描述函数 T2U<sub>4</sub> 的表格
> x|T2U<sub>4</sub>(x)
> -|-
> -8|
> -3|
> -2|
> -1|
> 0|
> 5|
***x***|***T2U<sub>4</sub>(x)***
-|-
***-8***|8
***-3***|13
***-2***|14
***-1***|15
***0***|0
***5***|5