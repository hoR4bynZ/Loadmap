## 第二章：程序结构和执行

### 练习题2.1：完成下列数字转换
> A. 将0x39A7F8转换为二进制  
> B. 将二进制1100100101111011转换为十六进制  
> C. 将0xD5E4C转换为二进制  
> D. 将二进制1001101110011110110101转换为十六进制  
```c
    // A. 0011_1001_1010_0111_1111_1000
    // B. 0xc97b
    // C. 1101_0101_1110_0100_1100
    // D. 0x26e7b5
```

### 练习题2.2：填写下表中的空白项，给出2的不同次幂的二进制和十六进制表示
> n|2<sup>n</sup>(十进制)|2<sup>n</sup>(十六进制)
> -|--------------------|-----------------------
> 9|         512        |         0x200
> 19|                   |
> | |       16384        |
> | |                    |         0x1000
> 17|                    |
> | |        32          |
> | |                    |          0x80

n|2<sup>n</sup>(十进制)|2<sup>n</sup>(十六进制)
-|--------------------|-----------------------
***9***|***512***|***0x200***
***19***|524288|0x80000
14|***16384***|0x4000
16|65536|***0x1000***
***17***|131072|0x20000
5|***32***|0x20
7|128|***0x80***

### 练习题2.3：一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制值
> 十进制|二进制|十六进制
> -----|------|-------
> 0|0000 0000|0x00
> 167|
> 62|
> 188|
> ||0011 0111|
> ||1000 1000|
> ||1111 0011|
> |||0x52
> |||0xAC
> |||0xE7

十进制|二进制|十六进制
-----|------|-------
***0***|***0000 0000***|***0x00***
***167***|1010 0111|0xa7
***62***|0011 1110|0x3e
***188***|1100 1011|0xcb
55|***0011 0111***|0x37
136|***1000 1000***|0x88
243|***1111 0011***|0xf3
82|0101 0010|***0x52***
172|1010 1100|***0xac***
231|1110 0111|***0xe7***

### 练习题2.4：不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六机制表示。提示：将执行十进制加法和减法所使用的方法改成以16为基数。
> A. 0x503c + 0x8 =  
> B. 0x503c - 0x40 =   
> C. 0x503c + 67 =  
> D. 0x50ea - 0x503c =
```c
    // A. 0x5044; B. 0x4ffc; C. 0x50a0; D. 0xae
```

### 练习题2.5：思考下面对 show_bytes 的三次调用：
> int val = 0x87654321;  
> byte_pointer valp = (byte_pointer)&val;  
> show_bytes(valp, 1); /* A. */  
> show_bytes(valp, 2); /* B. */  
> show_bytes(valp, 3); /* C. */  
> 指出在小端法机器和大端法机器上，每次调用的输出值  
> A. 小端法：&#8195;&#8195;&#8195;&#8195;大端法：  
> B. 小端法：&#8195;&#8195;&#8195;&#8195;大端法：  
> C. 小端法：&#8195;&#8195;&#8195;&#8195;大端法：  
```c
    // A. 小端法：21；大端法：87
    // A. 小端法：21 43；大端法：87 65
    // A. 小端法：21 43 65；大端法：87 65 43
```

### 练习题2.6：使用 show_int 和 show_float，我们确定整数 3510593 的十六进制表示为 0x00359141，而浮点数 3510593.0 的十六进制表示为 0x4a56_4504
> A. 写出这两个十六进制值的二进制表示  
> B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？  
> C. 串中的什么部分不相匹配？
```c
    // A. 0000_0000_0011_0101_1001_0001_0100_0001; 0100_1010_0101_0110_0100_0101_0000_0100
    // B. 21位匹配
    // C. 整数的开头部分和浮点数的开头部分不相匹配
```

### 练习题2.7：下面对 show_bytes 的调用将输出什么结果？
> const char *s = "abcdef";  
> show_bytes((byte_pointer)s, strlen(s));  
> 注意字母 'a' ~ 'z' 的 ASCII 码为 0x61 ~ 0x7a
```c
    // 会输出 61 62 63 64 65 66 00
```